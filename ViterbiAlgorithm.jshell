// package viterbiAlgorithm;

import java.util.Arrays;
import java.util.List;

class StateSequence {
	/**
	 * The sequence of states.
	 */
	public final String[] states;
	/**
	 * The logarithm of the probability of this sequence.
	 */
	public final double logProbability;

	public StateSequence(String[] states, double logProbability) {
		this.states = states;
		this.logProbability = logProbability;
	}
}

public class ViterbiAlgorithm {

	String states[];
	String observationVocab[];
	double[][] transitionMatrix;
	double emissionMatrix[][];

	public ViterbiAlgorithm(String[] states, String[] observationVocab, double[][] transitionMatrix,
			double[][] emissionMatrix) {
		// YOUR CODE HERE

		this.states = states;
		this.observationVocab = observationVocab;
		this.transitionMatrix = transitionMatrix;
		this.emissionMatrix = emissionMatrix;
	}

	public StateSequence getStateSequence(String[] observations) {

		double[][] viterbi = new double[states.length + 2][observations.length];
		int[][] backPointer = new int[states.length + 2][observations.length];
		List<String> observationVocabList = Arrays.asList(observationVocab);

		for (int s = 0; s < states.length; s++) {
			viterbi[s][0] = Math.log(transitionMatrix[0][s + 1])
					+ Math.log(emissionMatrix[s][observationVocabList.indexOf(observations[0])]);
		}

		for (int obs = 1; obs < observations.length; obs++) {
			// System.out.println("*******observation at "+obs+" is :
			// "+observations[obs]);
			for (int state = 0; state < states.length; state++) {
				// double temp = -Double.MAX_VALUE;
				// System.out.println("+++++++++The state is: " +states[state]);
				for (int state1 = 0; state1 < states.length; state1++) {
					// System.out.println("-----the previous state is "+state1);
					double temp1 = viterbi[state1][obs - 1] + Math.log(transitionMatrix[state1 + 1][state + 1])
							+ Math.log(emissionMatrix[state][observationVocabList.indexOf(observations[obs])]);

					// System.out.println("the value is: "+temp1);
					if(viterbi[state][obs]!=0){
					if (temp1 > viterbi[state][obs]) {
						backPointer[state][obs] = state1;
						// System.out.println("the backpointer is:
						// "+states[backPointer[state][obs]]);
						viterbi[state][obs] = temp1;
					}}
					else{
						backPointer[state][obs] = state1;
						viterbi[state][obs] = temp1;
					}

				}
			}
		}

		double temp = -Double.MAX_VALUE;

		// System.out.println("*****Final******");
		for (int state = 0; state < states.length; state++) {
			viterbi[states.length][observations.length - 1] = viterbi[state][observations.length - 1]
					+ Math.log(transitionMatrix[state + 1][states.length + 1]);
			// System.out.println("the state is: "+states[state]+" final value
			// is: "+viterbi[states.length][observations.length-1]);
			if (viterbi[states.length][observations.length - 1] > temp) {
				temp = viterbi[states.length][observations.length - 1];
				backPointer[states.length][observations.length - 1] = state;
				// System.out.println("back pointer new one is:
				// "+states[state]);
			}
		}
		int state = backPointer[states.length][observations.length - 1];
		String[] stateT = new String[observations.length + 1];
		stateT[observations.length] = states[state];
		for (int obs = observations.length - 1; obs > 0; obs--) {

			stateT[obs] = states[backPointer[state][obs]];
			state = backPointer[state][obs];
		}

		String[] str = new String[observations.length];
		for (int i = 0; i < str.length; i++) {
			str[i] = stateT[i + 1];
		}
		
		StateSequence seq = new StateSequence(str, temp);
		
		return seq;
	}

// 	public static void main(String arg[]) {
// 		String[] states = new String[] { "HOT", "COLD" };
// //		System.out.println(Math.log(3.439853568));
// 		double[][] transitionMatrix = new double[][] { { 0, 0.8, 0.2, 0 }, { 0, 0.6, 0.3, 0.1 }, { 0, 0.4, 0.5, 0.1 },
// 				{ 0, 0, 0, 0 } };
// 		String[] observationVocab = new String[] { "1", "2", "3" };
// 		double[][] emissionMatrix = new double[][] { { 0.2, 0.4, 0.4 }, { 0.5, 0.4, 0.1 } };
// 		String[] observations = new String[] { "3", "1", "3" };
// 		 observations = new String[] { "3", "2", "1", "1" };
// 		observations = new String[] { "1", "3", "3", "2", "3", "2", "1", "3", "1", "1", "1" };
// 		ViterbiAlgorithm v = new ViterbiAlgorithm(states, observationVocab, transitionMatrix, emissionMatrix);
// 		v.getStateSequence(observations);
	}

// This line should make sure that compile errors are directly identified when executing this cell
// (the line itself does not produce any meaningful result)
new ViterbiAlgorithm(new String[0],new String[0],new double[2][2],new double[0][0]);
System.out.println("compiled");

%maven org.junit.jupiter:junit-jupiter-api:5.3.1
import org.junit.jupiter.api.Assertions;
import org.opentest4j.AssertionFailedError;
import java.util.Arrays;

/**
 * Simple structure representing a list of expected state sequences.
 * Note that in very rare cases more than one solution is possible.
 * This is why this class offers an array of state sequences.
 * It is not necessary to use this in the student's implementation!
 */
public static class ExpectedStateSequence {
    /**
     * An array of expected states (and their alternatives).
     */
    public final String[][] states;
    /**
     * The logarithm of the probability of this sequence.
     */
    public final double logProbability;

    public ExpectedStateSequence(double logProbability, String[]...states) {
        this.states = states;
        this.logProbability = logProbability;
    }
}

public static final double DELTA = 0.000001;

public static void checkViterbi(String[] states, double[][] transitionMatrix, String[] observationVocab,
        double[][] emissionMatrix, String[] observations, ExpectedStateSequence expectedSequence) {
    try {
        ViterbiAlgorithm viterbi = new ViterbiAlgorithm(states, observationVocab, transitionMatrix, emissionMatrix);
        long time1 = System.currentTimeMillis();
        StateSequence sequence = viterbi.getStateSequence(observations);
        time1 = System.currentTimeMillis() - time1;
        System.out.println("Viterbi took " + time1 + "ms");
        // Check whether the result state sequence matches one of the expected
        // sequences 
        int id = 0;
        while((id < expectedSequence.states.length) && (!Arrays.equals(sequence.states, expectedSequence.states[id]))) {
            ++id;
        }
        // If there is no expected squence that fits to the given result
        if(id >= expectedSequence.states.length) {
            StringBuilder message = new StringBuilder();
            message.append("The determined sequence ");
            message.append(Arrays.toString(sequence.states));
            message.append("\n does not match the expected state");
            if(expectedSequence.states.length > 1) {
                message.append("s ");
                for(int i = 0; i < expectedSequence.states.length; ++i) {
                    message.append('\n');
                    message.append(Arrays.toString(expectedSequence.states[i]));
                }
            } else {
                message.append(' ');
                message.append(Arrays.toString(expectedSequence.states[0]));
            }
            Assertions.fail(message.toString());
        }
        double diff = Math.abs(expectedSequence.logProbability - sequence.logProbability);
        Assertions.assertTrue(diff < DELTA, "The calculated probability (" + sequence.logProbability
                + ") does not match the expected probability (" + expectedSequence.logProbability + ").");
        System.out.println("Test passed");
    } catch (AssertionFailedError e) {
        throw e;
    } catch (Throwable e) {
        System.err.println("Your solution caused an unexpected error:");
        throw e;
    }
}

String observations[];
ExpectedStateSequence expectedSequence;
String[] states;
String[] sequence;
double[][] transitionMatrix;
String[] observationVocab;
double[][] emissionMatrix;

System.out.println("---------- Ice cream example ----------");
states = new String[] { "HOT", "COLD" };
transitionMatrix = new double[][] { { 0, 0.8, 0.2, 0 }, { 0, 0.6, 0.3, 0.1 }, { 0, 0.4, 0.5, 0.1 },
        { 0, 0, 0, 0 } };
observationVocab = new String[] { "1", "2", "3" };
emissionMatrix = new double[][] { { 0.2, 0.4, 0.4 }, { 0.5, 0.4, 0.1 } };
observations = new String[] { "3", "1", "3" };
expectedSequence = new ExpectedStateSequence(Math.log(0.0009216), new String[] { "HOT", "HOT", "HOT" });
checkViterbi(states, transitionMatrix, observationVocab, emissionMatrix, observations, expectedSequence);

observations = new String[] { "3", "2", "1", "1" };
expectedSequence = new ExpectedStateSequence(Math.log(0.000288), new String[] { "HOT", "HOT", "COLD", "COLD" });
checkViterbi(states, transitionMatrix, observationVocab, emissionMatrix, observations, expectedSequence);

observations = new String[] { "1", "3", "3", "2", "3", "2", "1", "3", "1", "1", "1" };
expectedSequence = new ExpectedStateSequence(Math.log(3.439853568E-9), 
        new String[] { "HOT", "HOT", "HOT", "HOT", "HOT", "HOT", "HOT", "HOT", "COLD", "COLD", "COLD" });
checkViterbi(states, transitionMatrix, observationVocab, emissionMatrix, observations, expectedSequence);




System.out.println("---------- Ice cream example ----------");
observations = new String[1000];
Arrays.fill(observations, "3");
sequence = new String[1000];
Arrays.fill(sequence, "HOT");
expectedSequence = new ExpectedStateSequence(
        Math.log(0.8) + (999 * Math.log(0.6)) + (1000 * Math.log(0.4) + Math.log(0.1)), sequence);
checkViterbi(states, transitionMatrix, observationVocab, emissionMatrix, observations, expectedSequence);

// Ignore this cell

// Ignore this cell
